## Инфотекс — Система безопасности управления доступом

Реализация кейса: криптографически защищённая система контроля доступа с эмулятором карты, контроллера и админским интерфейсом. Решение разбито на две части: `frontend` (SPA) и `backend` (Spring Boot API).

### Соответствие ТЗ (MVP)
- Эмулятор карты: есть (веб-страница «Карта», генерация и хранение приватного ключа на стороне клиента).
- Эмулятор контроллера: есть (бэкенд-верификация тега с защитой от повторов через монотонный счётчик, HMAC-SHA256 с усечением тега до 16 байт).
- Кроссплатформенность/встраиваемость: есть (бэкенд на Java 17/Spring Boot; алгоритм прост и переносим на встраиваемые контроллеры; фронтенд — работает в браузере, без внешних зависимостей на сервер).

### Дополнительные задачи
- Простая администрация: есть экран «Администрирование» (демо: добавление/отключение пользователей), API для управления картами (`/api/admin/*`: статус, продление, отзыв).
- Минимизация секретов: приватные ключи «карты» хранятся локально (не уходят на сервер). На сервере хранятся пер-карта мастер-ключи (Kmaster) и счётчики.
- Срок жизни: поддерживается TTL карт на бэкенде (персонализация с `ttlSeconds`, продление `/extend`).
- Автономность: система не требует внешних глобальных сервисов (все вычисления локальны/на своём API).

---

## Архитектура и криптография

- Крипто-алгоритм: используется HMAC-SHA256 (не CMAC); тег усечён до 16 байт.
- Карта: идентификатор `cardId` (base64url(16)) и секрет `kMaster` (base64url(32)). При ответе карта инкрементирует счётчик `ctr` (LE64) и вычисляет `tag = Trunc16(HMAC_SHA256(kMaster, cardId || ctr))`.
- Контроллер: проверяет срок действия и активность карты, монотонность `ctr`, пересчитывает `tag` и сравнивает в константное время.
- Веб‑карта (SPA): генерирует ключевую пару ECDSA P-256 для подписания челленджей от считывателя (демо-функционал), хранит приватный ключ только локально (LocalStorage). Это демонстрирует подход к минимизации секретов на сервере.

Ключевые файлы (ветка `backend`):
- `backend/src/main/java/backend/service/CardService.java` — HMAC‑SHA256, проверка тега, анти‑replay по счётчику.
- `backend/src/main/java/backend/api/CardController.java` — создание карт, верификация.
- `backend/src/main/java/backend/api/AdminController.java` — отзыв/продление/статус/список.
- `backend/src/main/java/backend/api/SimController.java` и `sim/SimService.java` — эмуляция ответа карты (ctr/tag).
- `backend/src/main/resources/openapi.yaml` — спецификация API.

Ключевые файлы (ветка `frontend`):
- `src/lib/crypto.ts` — ECDSA P‑256, подписание челленджа, JWK import/export, nonce/TTL.
- `src/pages/Card.tsx` — «Карта»: генерация пары ключей, сканирование QR с челленджем, подписание и отправка ответа (демо‑поток).
- `src/pages/Reader.tsx` — «Считыватель/контроллер» (сканирование/генерация челленджа через QR, демо‑поток).
- `src/pages/Admin.tsx` — «Администрирование»: демо‑управление пользователями; для карт — REST‑эндпоинты на бэкенде.
- `src/pages/Events.tsx`, `src/pages/Index.tsx` — навигация/демо‑экраны.

---

## API (backend)

Базовый URL: `http://localhost:8080`

- POST `/api/cards` — персонализация карты
  - body: `{ owner: string, ttlSeconds: number }`
  - resp: `{ status, cardId, owner, expiresAt }`
- POST `/api/sim/response/{cardId}` — эмуляция ответа карты (ctr/tag)
  - resp: `{ status, ctr?, tag? }`
- POST `/api/cards/verify` — проверка на контроллере
  - body: `{ cardId, ctr, tag }` // base64url
  - resp: `{ status: OK|FAIL }`
- POST `/api/admin/revoke/{cardId}` — деактивация
- POST `/api/admin/extend/{cardId}?extraSeconds=...` — продление срока
- GET `/api/admin/status/{cardId}` — карточка по id
- GET `/api/admin/list` — список карт

Подробности — в `backend/src/main/resources/openapi.yaml`.

---

## Локальный запуск

Требования: JDK 17+, Node 18+.

Backend (ветка `backend`):
1. Сборка/запуск: `./gradlew bootRun`
2. Сервер поднимется на `http://localhost:8080`

Frontend (ветка `frontend`):
1. Установить зависимости: `npm i` или `yarn`
2. Запуск dev: `npm run dev`
3. Указать переменную окружения `VITE_API_URL` (например, `http://localhost:8080`)

---

## Демо‑сценарии

1) Персонализация карты (админ/бэкенд)
- POST `/api/cards` → получаем `cardId`
- Опционально: сгенерировать ответ «карты» через `/api/sim/response/{cardId}` и проверить `/api/cards/verify`

2) Веб‑карта + считыватель (фронтенд)
- На странице «Карта» создать ECDSA‑ключи (хранение приватного ключа локально)
- На странице «Считыватель» сгенерировать челлендж (QR), отсканировать его «Картой», сформировать подпись и отправить

---

## Что сделано дополнительно к базовому заданию

- Веб‑карта на ECDSA P‑256 (минимизация секретов на сервере, переносимость на смарт‑карты/апплеты).
- Анти‑replay через монотонный 64‑битный счётчик (серверная проверка).
- Константное сравнение тегов на сервере.
- Админ‑API для управления жизненным циклом карт (revoke/extend/status/list).
- QR‑потоки для челленджа/ответа: удобная демонстрация оффлайн‑сценариев.

---

## Стек

- Backend: Java 17, Spring Boot, HMAC‑SHA256 (JCE), OpenAPI 3.0
- Frontend: Vite + React + TypeScript, WebCrypto API (ECDSA P‑256), shadcn/ui
- Интеграции: QR‑сканер/генератор для оффлайн‑обмена

---

## Безопасность и дальнейшее развитие

- Перенос алгоритма на встраиваемые устройства: реализация HMAC‑SHA256 и счётчика доступна на MCU; публично‑частные ключи ECDSA могут жить на смарт‑карте/TPM.
- Ротация Kmaster: выпуск новых карт/персонализация; хранение ключей на HSM.
- Политики TTL по ролям: поддержка разных профилей и авто‑ревока при истечении.
- Полностью оффлайн‑режим: обмен только через QR/звуковой канал.